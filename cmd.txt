/************************************************************************************/
  VSCode Extensions to install:
    C# for Visual Studio Code (powered by OmniSharp)
    C# Extensions JosKreati
    Docker
    Material Icon Theme
    NuGet gallery
    Sqlite
    Rainbow CSV

  ADD GIT IGNORE FILE
  From Dot.Net core 3.0, .gitignore can be easily added by simple command. 
  Run "dotnet new gitignore" on project root folder.

/************************************************************************************/
--install dotnet 7 SDK, node JS 18.12.1 LTS
--install from NUGET packet manager: Microsoft.EntityFrameworkCore.Sqlite
-- Install from dotnet cli: dotnet tool install --global dotnet-ef --version 7.0.1


-- install node version management (nvm): it allows to swicht from npm version to another
link: https://joachim8675309.medium.com/installing-node-js-with-nvm-4dc469c977d9
      https://chocolatey.org/install
    Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
    choco install cmder
    choco install nvm
    refreshenv

/************************************************************************************/
before start, we must know how to choose the correct .net version we want to use for our project.
In order to change the dotnet version, we must do:

You can do this with a global.json file in the root of your project:

Verify the list of SDKs on your machine:
    dotnet --list-sdks
You'll see a list like this.

2.1.100 [C:\Program Files\dotnet\sdk]
2.1.101 [C:\Program Files\dotnet\sdk]
2.1.103 [C:\Program Files\dotnet\sdk]
2.1.104 [C:\Program Files\dotnet\sdk]
[...lines omitted...]
2.1.601 [C:\Program Files\dotnet\sdk]
2.2.101 [C:\Program Files\dotnet\sdk]
3.0.100-preview3-010431 [C:\Program Files\dotnet\sdk]
Create a folder to be the root of your project, where you are going to run dotnet new.
In that folder, run this command: dotnet new globaljson
The result will look something like this:

{
  "sdk": {
    "version": "3.0.100-preview3-010431"
  }
}
In version, replace the 3.0.100-preview3-010431 with the version you prefer from the --list-sdks list. For example:
{
  "sdk": {
    "version": "2.2.101"
  }
}
Run dotnet --version to verify. You should see:
2.2.101


/************************************************************************************/
commands to create the project from git cli:

    mkdir Reactivities
    cd Reactivities
    dotnet new sln              #(this creates Reactivities.sln file)
    dotnet new webapi -n API    #(this creates a new webapi project folder named API and files)
    dotnet new classlib -n Application
    dotnet new classlib -n Domain
    dotnet new classlib -n Persistence 

    dotnet sln add API/API.csproj
    dotnet sln add Application
    dotnet sln add Domain
    dotnet sln add Persistence

    cd API 
    dotnet add reference ../Application
    cd ..; cd Application
    dotnet add reference ../Domain
    dotnet add reference ../Persistence

    cd ..; cd Persistence
    dotnet add reference ../Domain

    dotnet run
    dotnet watch run

  
  /************************************************************************************/
  Install MicrosoftEntityFrameworkCore.sqlite v5.01 into the Persistence class library project 
  (same SDK version as API, Domain, Persistence projects) via NUGET gallery

MAKE SURE TO RUN THE APP ALMOST ONE TIME AFTER MicrosoftEntityFrameworkCore install
    dotnet run
    dotnet watch run

STOP the Application using Ctrl+C
Then, in order to create the DB, we will create a migration using ef
cd Reactivities
INSTALL DOTNET EF
    dotnet tool install --global dotnet-ef --version 5.0.1
    dotnet tool list --global
    dotnet ef -h
    dotnet ef migrations add InitialCreates -p Persistence -s API/ #this command creates a migration.
to do this, run: dotnet ef migrations add MigrationName -p dbProjectName -s StartupProjectName/

  /************************************************************************************/
  HOW TO RUN OUR PROJECT:
  To build and run our .net project, just run this command from the CLI:
    dotnet watch --no-hot-reload
  this will reload the app after every file update

  /************************************************************************************/
  HOW TO CREATE THE GIT REPO + GITIGNORE FILE
  in order to list all availables commands for dotnet cli, just type: 
    dotnet new -l

  in order to create a new GIT repo for our project, just type from the CLI:
    git status #this will tell us that our current folder is not a GIT repository. 
    git init #this will initiate a GIT repo for our project
  
  in order to upload into our new repo only "imports" files of our project, we can create a gitIgnore file for a dotnet project:
    dotnet new gitignore

  /************************************************************************************/
  HOW TO CREATE THE CLIENT APP?
  To create the client app using REACT, we need to run the following cmd:
    npx create-react-app client-app --use-npm --template typescript
    npx create-react-app <app-name> --use-npm --template typescript

  PS: en cas de soucis, je dois me souvenir que les versions de node (node -v) et de NPM (npm -v )
  sont différentes de celles use dans le tuto.

  En cas de soucis plus en avant, il faudrait installer les mêmes versions que dans le tuto á savoir:
    node version 16.16.0
    npm  version 8.11.0 
  et switcher sur ces dernières!!!

  Remember to install chrome extension REACT DEVELOPPER TOOLS 
  install AXIOS for fetching/retrieving data from our API. An alternative is FETCH
  To install AXIOS,run the following cmd:
    npm install axios
  
  install semantic-ui: npm install semantic-ui-react semantic-ui-css
  /************************************************************************************/
  HOW TO IMPLEMENT CQRS PATTERN?  
  In order to communicate between different level of our app, we need a mediator.
  We must install for 'Application' Project MediatR.Extensions.Microsoft.DependencyInjection v.11.0.0 by Jimmy Bogard from NugetGallery
 
  Install Automapper AutoMapper.Extensions.Microsoft.DependencyInjection v.12.0.0 by Jimmy Bogard into our 'Application' project

  /************************************************************************************/
  FRONT END: How to generate GUID from the front:
  to do this, we must install this package into the root folder of client App
    npm install uuid
    npm i --save-dev @types/uuid
  
  /************************************************************************************/
  HOW TO MANAGE THE STATE OF REACT?
  In order to manage the state, we can use MobX or 'MobX React Lite'. Une alternative serait de use react Redux
  Each component could communicate with the state via The 'React Context'.

  MobX uses classes to store the state. we create classes for each store we create. To change the value of a property
  which is an 'observable', we need action.
    Why MobeX?
    - It's written into TypeScript. So it is a good approach for our project
    - It's use Observables(c'est le futur des 'promises' en javascript. contrairemement aux promises qui sont ponctuelles 
      sans suivies, il est possible de suivre les eventuelles changement d'etat de nos variables 'OBSERVABLES')
    - It's use action. (actions change the state of Observables)
    - Computed properties
    - Reactions
    - Autorun
  Reaction is a benefit of use of MobX. A reaction is an action to do when the state of the property changes.

  example:

  import { reaction, makeAutoObservable, action, computed, makeOservable, observable} from 'mobx'
  import {createContext} from "react"

  class DemoStore{
    firstName = 'Bob',
    lastName = 'Smith'
  }

  Constructor(){
    
    /*this, {
      firstName: observable,
      lastName: observable,
      setFirstName: action,
      fullName: computedmakeOservable(t
    })*/
    makeAutoObservable(this);
    
    /*reaction: on doit preciser dans une reaction le param qu'on veut 'observer' ainsi que la 
    fonction/reaction a faire quand ce param observer change d'etat ou de valeur
    */
    reaction(
      () => this.firstName,  /*observabele param*/
      (firstName) => console.log(firstName) /*action to do: log into the console firstName everytime it value change's*/
    )
  }

  /*action*/
  setFirstName = (name: string) => {
    this.firstName = name;
  }

  /*computed property: it allows us to get a new Property from our store properties*/
  get fullName = () => {
    return this.firstName + ' ' + this.lastName;
  }

  export default createContext(new DemoStore());

  -----

  import React, {useContext} from 'react';
  import DemoStore from '../app/demoStore';

  export default function Demo(){
    const demoStore = useContext(DemoStore);
    const {fullName} = demoStore;

    return (
      <div>
        <h1>Hello {fullName}<h1/>
      <div/>
    )
  }
  -----
  
  /************************************************************************************/
  HOW TO INSTALL MobX and 'MobX React Lite'
  Just run the following cmd:
    npm install mobx mobx-react-lite

  /************************************************************************************/
  HOW TO ROUTE REACT APPS?
    <BrowserRouter> we will surround our app with a <BrowserRouter> component inside our app, 
      we will use <Route> component which will load the particular component called during the navigation inside the app
    <Link> we urround a button with a <Link> component for example
    <NavLink> we use <NavLink> to make a button unactive when a link is click on it
    <Redirect> is an option to redirect the user

  React Router hook
    useHistory.goBack(), go(), goForward(), location(), match()... : keeps track of current location/re-renders the componentwhen
       change detected
    useLocation
    useParams
    useRouteMatch
  
  HOW TO  INSTALL REACT ROUTER?
    npm install react-router-dom
  
  /************************************************************************************/
  HOW TO SELECT DATE?
  In to display and select a particular date (start date of an activity for example), we need to install react-calendar package:
    npm install react-calendar

  /************************************************************************************/
  HOW TO MANAGE VALIDATION FROM THE BACK?
  To manage validation, we can do it directly from the Model. But this is not what we want.
  In order to improve the app, we validate our data into the Application Project. Doing that, 
  our objects are validated before any elaboration and before sending/retrieving them from the DB.
  WE GAIN IN EFFICIENCY.

  We need to install from NugetGallery FluentValidation.AspNetCore into application project(v.11.2.2)
  checkOut the doc: https://docs.fluentvalidation.net/en/latest/aspnet.html

  for this course, we use autoValidation

  /************************************************************************************/
  HOW TO MANAGE ERROR ?
  To manange error inside our app, we create a Middleware class (ExceptionMiddleware) which is Injected
  into the app after the app is builded.

  Then, we added a controller for testing purpose and a NavLink(/Errors) from the from.

  Now, in order to notify the end user of what is happening into the app, we need to install a notification 
  package:
    npm install react-toastify
  
  /************************************************************************************/
  HOW TO DROP DB using Entity Framweork CLI
  go to the solution level into your project. Open the CLI at the solution level and run the cmd:
    dotnet ef database drop -s API -p Persistence
  
  /************************************************************************************/
  HOW TO MANAGE FORMS for data handling from the frontEnd?
    - We will use FORMIK which is one of the most popular library for react forms
      npm install formik
    - to validate inputs from the form, we will use Formik/Yup 
      npm install yup
      npm install @types/yup --save-dev
    - to manage Date in the frontEnd, we will use ReactDatePicker/TimePicker package
      npm install react-datepicker

  /************************************************************************************/
  HOW TO MANAGE AUTHENTICATION INTO THE APP?
  Now, it's good idea to use JWT (Json Web Token) for apps based on API. 
  Beside JWT, we will use ASP.NET Core Identity which has the following functionalities:
    - MemberShip System
    - Supports login stored in Identity (logins will be stored into the DB)
    - Supports external providers (connect throught facebook for example)
    - Comes with defautl user stores (it's create some defaults table into the DB)
    - UserManager: maange user (create, find, get a user)
    - SignInManager: get the user pwd as a string, and then compare it to the hashed pwd stored into the DB

  To do this, we must install:
      Microsoft.AspNetCore.Identity.EntityFrameworkCore by Microsoft version 5.0.1 from NugetGallery forthe library: Domain
    then we create an EntityFrameworkCore migration: 
      dotnet ef migrations add IdentityAdded -p Persistence -s API
    from the solution reactivities.sln Level. the migration will create tables:
      - AspNetRoles
      - AspNetUsers
      - AspNetRoleClaims
      - AspNetUserClaims
      - AspNetUserLogins
      - AspNetUserRoles
      - AspNetUserTokens
      - AspNetUserRoles

  to Manage JWT token (SymmetricSecurityKey), we must install: 
    System.IdentityModel.Tokens.Jwt by Microsoft v.6.25.0 from NugetGallery into the API project

  il existe plusieurs facons de creer des services dans Program.cs etc... pour une app.
    
    - service.AddScoped<NomDuService>(); ==> cree un service á chaque requete http(s)
      par exple: services.AddScoped<TokenService>(); cree un token lorsqu'une requete http de login sera lancée
    
    -services.AddTransient<NomDeLaMethode/NomDeLaClass>(); ==> cree un service pour une methode/class
    
    -services.AddSingleton<NomDeLaMethode>(); ==> cree un service qd l'app demarre. Le sercice ainsi cree est maintenu
      en vie jusqu'a l'arret de l'appli

  Install Microsoft.AspNetCore.Authentication.JwtBearer by Microsoft version 7.0.0 from NugetGallery into the API project

  /************************************************************************************/
  Configure RELATION MANY TO MANY between Activity and AppUser
  Run the migration from the Reactivities root folder:
    dotnet ef migrations add ActvityAttendee -p Persistence -s API

  /************************************************************************************/
  HOW TO ACCESS TO USER/TOKEN INFOS INTO THE APPLICATION PROJECT?
  To do this clearly, we can create a Service (in this case a new ClassLibrary project called Infrastructure) which
  will infos on the user and token to "Application" Project.
  
  the into the "Application" project, we need to create an Interface

  cd Reactivities
  dotnet new classlib -n Infrastructure
  dotnet sln add Infrastructure
  cd Infrastructure/
  dotnet add reference ../Application
  cd ..
  cd API/
  dotnet add reference ../Infrastructure

  /************************************************************************************/
  HOW TO DROP DB TO IMPORT NEW SEED (MOCK) DATA, RUN THE following CMD FROM THE ROOT FOLDER (Reactivities)
    dotnet ef database drop -p Persistence -s API
    cd API
    dotnet watch run 

  /************************************************************************************/
  SECTION 1: IMAGE STORAGE
    - where can we store image into our application?
    - which options do we have: 
      * Database: store image/files into the DB presents some inconvenients like:
        . inefficiency
        . we must store files as BLOBs
        . disk space could be an issue
        . Authentication is easy

      * File System: it's a good place to store files but...
        . disk space could be an issue
        . file permissions (read/write)
        . recovery issue if the storage is KO

      * Cloud Service: definitievely the better but expensive solution to store file used by an application
        . cloud is higly scalable
        . but infortunatelly, it could be more expensive depending on the size of our files
        . it's secured with API key

    - add a photo upload service 
    - How to use a cloud service (Cloudinary API) specialized in image storage into the cloud
      to add Cloudinary into our Infrastructure project, just open NugetGallery and find:
      CloudinaryDotNet by Cloudinary v.1.14.0 and then install it into Infrastructure project

      then get info from our cloudinay account and assign these info (cloudName, APIKey, APISecrete) into 
      the config file (appsettings.json) of the Application

      after created the Photo Class, run the following EF migration in order to create the table
        cd ..; dotnet ef migrations add PhotoEntityAdded -p Persistence -s API 
      
  /************************************************************************************/
  SECTION 17: Image Upload from the front
  In order to upload image from the front, we can use drag&drop functionality. TO do this, we could
  use the package: react-dropzone
      npm install --save react-dropzone
  
  https://github.com/react-dropzone/react-dropzone

  install react-cropper: it allows us to resize/crop an image
      npm install --save react-cropper

  /************************************************************************************/
  SECTION 19: signalR
  What is SignalR:
    Adds real time web functionality to apps
    it allows connected clients to receive content instantly (when the server update some data, the client will receive these update instantly)
    it is ideal for:
      - chat apps
      - dashboard
      - Monitoring
    it has to possibility to use 3 differents types of transport:
      - WebSockets : (meilleure option) connexion bidirectionnelle entre le srv et le client (á condition que les 2 supportent le webSocket)
      - Server-sent events: (au cas oú le webSocket ne serait pas pris en charge par le srv/client ou les 2, alors, une alternative de transport
         de l'info est : server-event/eventSource supporté par la plus part des browser á l'exception d'Internet Explorer avant la v10)
      - Long polling (pire des solutions car il cree des latences quand la connexion reprend): crée un connexion Persistante ouverte 
        entre le client et le srv jusquá ce que le server reponde.

    SignalR use a HUB to provide us 2 types of objects to manage the connection between the server and the client
      - Context: it's an object which provides ConnectionId, UserIdentifier, User, GetHttpContext() .... 
      - clients: (AllExcept, client, Group (group of client connected to), Caller (to user who sent the request to the server), Others (every body except the caller)...)

    en resumé, le HUB permet de:
      - Allows connected clients to call methods on server
      - can send notification to connected clients
    
    create a migration for the new Comment table: 
      dotnet ef  migrations add CommentEntityAdded -p Persistence/ -s API

    How to install signalr for the client papp?
      npm install @microsoft/signalr

  /************************************************************************************/
  HOW TO CREATE UML ?

  you can use https://vertabelo.com/ in order to create a UML diagram: you can generate a SQL script from 
  a Entity framework migration, then create aphysical model of data

  how to create a sql script using EF?
  from the root folder just run the cmd:

  dotnet ef migrations script -o migrationScriptTest.sql -p Persistence -s API
  
  /************************************************************************************/
  HOW TO MANAGE PAGING, SORTING ?

  in this section, we will do:
    - paging on the APi and Client. Actuellement, l'API retourne la list des item quand on fait 
    un get. Si l'application a peut de données, on est bon. Mais si le nbre de données et de requetes
    vers l'api augmentent, alors, il est bon de faire une pagination
    - Sorting on the API/Client
    - Filtering on the API/Client

    PAGING, SORTING, FILTERING sont des méthodes qu'on peut implementer dans des IQueryable<T>.
    Nous allons stocker nos requetes dans des IQueryable<T> jusqu'au moment de les utiliser

    What is IQueryable<T>?
      - query variable stores query commands (query commands can be thinks like orderBy, Where etc...)
      - using IQueryable<T>, we will creates an expression tree. 
        
        * the execution of the expression will be deferred until iteration (ForEach loop, ToList(), 
          ToArray(), ToDictionary(): sont les expressions qui declenchent l'execution de la query dans la DB).

        * Singleton queries (count, average etc...) will cause our queries to be executed inside the DB

  exple:
    var queryable = _context.Activities
      .Where(x => x.Date >= request.StartDate)
      .OrderBy (x => x.Date)
      .AsQueryable(); // queryable est notre requete proprement dite

    var activities = await queryable.Skip (request.Offset ?? 0)
      .Take(request.Limit ?? 3) // SKIP et TAKE sont des operateurs de pagination
      .ToListAsync(); //toList execute reellement la requete

    Pour le front, nous allons gerer la pagination á la facon de twitter avec le LA PAGINATION VERTICALE.
    Il s'agit en quelques sorte du vertical scrolling "infini". Pour cela, on doit installer la package:
      npm install react-infinite-scroller
      npm install @types/react-infinite-scroller

  /************************************************************************************/
  Comment éviter que le lors de l'ouverture d'un component ou d'une page, il faille stroller vers le haut?
  Pour cela, il suffit de rajouter Le composant <ScrollRestoration /> dans le composant racine App.tsx

  /************************************************************************************/
  To create a production build of our app, just go to the link https://create-react-app.dev/docs/production-build
  and follow the instructions. We can specify the path where the build result will be store by adding BUILD_PATH=ourPath
  into the package.json/scripts/build
  Exple: "build": "set BUILD_PATH='../API/wwwroot'&& react-scripts build",

  run 
    npm run build
    
  /************************************************************************************/
  How to DOCKER-ize the app?
  - we can use PostGresSQL directly fromt Docker installation
    https://www.docker.com/products/docker-desktop/
  

  Enable Hyper V from Powershell (opened as Admin and run the command)
     dism.exe /Online /Enable-Feature:Microsoft-Hyper-V /All
     bcdedit /set hypervisorlaunchtype auto

  In order to remove Sqlite and use Postgres in Production mode, we must:
    - delete Migrations Folder from Persistence project
    - run the following cmd: 
      dotnet ef database drop -p Persistence -s API
    - check DB providers config from 
      https://learn.microsoft.com/en-us/ef/core/providers/?tabs=dotnet-core-cli
    - Install "Npgsql.EntityFrameworkCore.PostgreSQL by Shay Rojansky,Austin Drenski,Yoh Deadfall" from NugetGallery
    the version to install MUST be the same as the EntityFrameworkCore and Dotnet Version. In our case, it's 7
    then install this package for the Persistence project.
    - create a new MIgration: 
      dotnet ef migrations add PostgresInitial -p Persistence/ -s API/

    after installed docker, you can run an instance of postGres using the following command:
      docker run --name dev -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=secret -p 5432:5432 -d postgres:latest

      OUVRIR DOCKER DESKPTOP, RUN L'IMAGE dev DU SERVEUR POSTGRES

      RUN THE APP USING from the API folder using:
        dotnet run

      install postgres extension on vsCode then connect to the local DB by
        - create new connection: hostname = localhost
        - userName: admin, password =secret, port=5432, standardConnection,


    - To deploy our app, we can use Heroku (no longer free).
    An alternative is Fly.io (https://fly.io/).

    In order to deploy our app on fly.io, we will create a DOCKER IMAGE of our app and then deploy the created image
    on fly.io server
      https://fly.io/docs/languages-and-frameworks/dockerfile/

      in order to create the app image and store it into a public repo, we must created an account on hub.docker

    - install docker (from microsoft) extension for vsCode
    - at the root folder, create "Dockerfile"
    Dockerfile content is:

      #this cmd specify the image from which we want to start from. 
      #It's the base image. We MUST SPECIFY THE SDK VERSION OF THE APP
      #build-env: represents the stage: everytime we create an image, we start from a place so, we don't need to repeat
      #some task each time we create the app new image
      FROM mcr.microsoft.com/dotnet/sdk:7.0 as build-env
      
      #WORKDIR: is the file location into Docker container
      WORKDIR /app

      #copy .csproj and store as distinct layers
      #this cmd will copy <E:\projects\dotnetcore7react18\Reactivities\Reactivities.sln> into the /app(docker container) folder
      COPY "Reactivities.sln" "Reactivities.sln" 
      COPY "API/API.csproj" "API/API.csproj"
      COPY "Application/Application.csproj" "Application/Application.csproj"
      COPY "Persistence/Persistence.csproj" "Persistence/Persistence.csproj"
      COPY "Domain/Domain.csproj" "Domain/Domain.csproj"
      COPY "Infrastructure/Infrastructure.csproj" "Infrastructure/Infrastructure.csproj"

      #restore command will run, build and download all packages which are necessaries for the app.
      RUN dotnet restore "Reactivities.sln"

      #copy everything from source to destination (app folder) else and build. 
      COPY . .
      WORKDIR /app /*after the copy, we must specify the WORKDIR*/
      #Now we build the app from dotnet using a config (-c <=> configuration; -o = output directory)
      RUN dotnet publish -c Release -o out

      # build a runtime image
      FROM mcr.microsoft.com/dotnet/aspnet:7.0.1

      # now we copy the build result from the "out" directory into the "app" folder
      COPY --from=build-env /app/out/ .
      WORKDIR /app /*after the copy, we must specify the WORKDIR*/
      # then we specify the entryPoint and the startup project which is API
      ENTRYPOINT [ "dotnet", "API.dll" ]

    - the file ".dockerignore" contents only folder/files which we want to ignore/don't copy into the container

    - then go back to the root folder of the project (Reactivities) and run the following cmd:
      /*
        stnmboa = username on hub.docker
        reactivities = name of docker image we want to create
        " ." = copy everything
      */
        docker build -t stnmboa/reactivities:latest .
        docker push stnmboa/reactivities:latest


    - For testing purppose, we could run the app from localhost:8080, just run the cmd
      -rm: remove the image when we stop the run
      -it: run the image in INTERACTIVE MODE
        docker run --rm -it -p 8080:80 stnmboa/reactivities
    
    - How to push the image into the hub.docker?
      * first: from the command line, login into docker with the cmd: 
        docker login (with username and password)
      * the push the image to hub.docker
        docker push stnmboa/reactivities:latest

  /************************************************************************************/
  AFTER CREATED A DOCKER IMAGE, HOW TO DEPLOY THE APP ON FLY.IO?
    In to order to deploy the app on fly.io, we must read the documentation: https://fly.io/docs/speedrun/
      * install flyctl: flyctl is a command-line utility that lets you work with Fly.io, from creating your 
        account to deploying your applications. It runs on your local device so you'll want to install the 
        version that's appropriate for your operating system.

        windows install command: 
          powershell -Command "iwr https://fly.io/install.ps1 -useb | iex"

      * After installed the flyctl, just sign in into Fly.io using your github repo (better solution)
        fly auth signup

      * then Sign In into FlyIo. Your browser will open up with the Fly.io sign-in screen, enter your user name 
        and password to sign in. If you signed up with GitHub, use the Sign in with GitHub button to sign in.
        Microsoft WSL users may need to run the following command to make this work:

          ln -s /usr/bin/wslview /usr/local/bin/xdg-open
          fly auth login 
          (une requete d'ajout de carte de credit peut obligatoire afin de deployer son APP)

      * to launch the app on Fly.io with the cmd:
        fly launch --image stnmboa/reactivities:latest
          - ? Choose an app name (leave blank to generate one): reactivities-api-app
          - ? Choose a region for deployment: Paris, France (cdg) : select the default
          - ? Would you like to set up a Postgresql database now? Yes
              after this, we MUST SAVE DB CONNECTION INFO INTO A SAFE PLACE. WE DO NOT HAVE ANOTHER OPTION THE SAVE THEM AFTER
          - ? Select configuration: Development - Single node, 1x shared CPU, 256MB RAM, 1GB disk: this is the FREE option
          - ? Would you like to set up an Upstash Redis database now? ==> NO
          - ? Would you like to deploy now? NO
              we will deploy the App after because we need to config something else

          this will generate a file called fly.toml. it content could be:




          # fly.toml file generated for reactivities-api-app on 2023-04-06T07:30:05+02:00

                          app = "reactivities-api-app"
                          kill_signal = "SIGINT"
                          kill_timeout = 5
                          primary_region = "cdg"
                          processes = []

                          [build]
                            image = "stnmboa/reactivities:latest"

                          #[ENV] allows us to set some env variables. for exple, we need to specify to fly.io that we want to app to
                          # run on port 8080. to do so, we can set ASPNETCORE_URLS and other not secret config value like Cloudinary (cloudname, apiKey)

                          [env]
                            ASPNETCORE_URLS="http://+:8080"
                            Cloudinary__Cloudname="dvyclpuks"
                            Cloudinary__ApiKey="245423816678958"

                          [[services]]
                            internal_port = 8080
                            processes = ["app"]
                            protocol = "tcp"
                            [services.concurrency]
                              hard_limit = 25
                              soft_limit = 20
                              type = "connections"

                            [[services.ports]]
                              force_https = true
                              handlers = ["http"]
                              port = 80

                            [[services.ports]]
                              handlers = ["tls", "http"]
                              port = 443




      * to deploy the app, jut run the cmd:
        flyctl deploy

  /************************************************************************************/
  HOW TO STORE SECRET INFO using Fly.io?
  - by run this cmd: 
    fly secrets list

  - To generate strong password, we can use https://delinea.com/resources/password-generator-it-tool
  - For Docker, I don't recommand to use special characters/Symbols (%^&!#@%^..=) into the Password because docker doesn't like them

  - We need to set all secret Key presents into appsettings.json into the fly secrets list:
    fly secrets set TokenKey=sEe8ekxINwGafsbsHz
    fly secrets set Cloudinary__ApiSecret=uvDbMuIx

  - after updated the connectionString config into ApplicationServiceExtensions, we must build again the 
  app using Docker and push a new image to hub.docker

  /************************************************************************************/
  FINALLY, WE CAN DEPLOY THE APP
  - migrate the repo from gitlab to github
  - then clone it locally
  - into the main project root folder (Reactivities in this case), cree the workflow folder 
    following the path: .github/workflows/docker-push.yml

    the content of the file docker-push.yml must be somthing like

              name: ci #name of the file

              on:
                push:
                  branches:
                    - 'main'

              jobs:
                docker:
                  runs-on: ubuntu-latest
                  steps:
                    -
                      #name: Set up QEMU #we don't need this
                      #uses: docker/setup-qemu-action@v2 #we don't need this
                    -
                      name: Set up Docker Buildx #this will biuld a docker image for us
                      uses: docker/setup-buildx-action@v2
                    -
                      name: Login to Docker Hub
                      uses: docker/login-action@v2
                      with:
                        username: ${{ secrets.DOCKERHUB_USERNAME }} #this info will be store into gitHub web site 
                        password: ${{ secrets.DOCKERHUB_TOKEN }}
                    -
                      name: Build and push
                      uses: docker/build-push-action@v4
                      with:
                        push: true
                        tags: user/app:latest

  - how to store secrets.DOCKERHUB_USERNAME/DOCKERHUB_TOKEN
    - go the github/reactivities repo
    - click on settings (settings of this repo)
    - from the security tab, select action / new repository secret

  - after created the docker-push.yml file, commit everything and then push everything to the main branch.
  then, go back to github repo/actions. now, we must see a button called docker-push.
  we have to click on "run the workflow" and then wait for the build and run result

  - if the worklow runs without errors, go back to the vsCode and run the following cmd to deploy the app 
  on fly.io with the latest modifications
    fly deploy

  /************************************************************************************/
  HOW TO GET LOGS FROM FLY.IO after app deployed?
    - we can get the logs via the fly.io web site
    - or via the cmd line using the cmd:
      fly auth login
      fly logs --app <app_name>

  /************************************************************************************/
  Comment faire en cas de bug/ou d'ajout de nouvelle fonctionnalité?

  1) on crée une branche partant de la branche la plus avancée (branch main)
  2) on nomme la branche créée suivant la feature/bug-fix á implementer
  3) on se positionne la nouvelle branche créée, on fait le dev
  4) HORS CONTEXT: afin que l'image docker soit recréée et redeployer lorsque nous faisons un PUSH sur la
                   la branche MAIN, on rajouter au modifie le docker-push.yml de la façon suivante:
                   (ATTENTION AU ESPACE, AU TAB ETC... CAR LES FICHIERS.YML SONT TRES CAPRICIEUX) 


name: docker-push #NOM DU FICHIER

on:
  workflow_dispatch:
  push: #LE DEPLOY S'ACTIVE QUAND JE PUSH SUR LA BRANCHE MAIN
    branches:
      - 'main'
env:
  FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }} #SECRET KEY MISE DANS LA REPO/SETTINGS/ACTIONS; CE TOKEN EST OBTENU AVEC LA CMD: $fly auth token
jobs:#LISTE DES JOBS DOCKER A EXECUTER
  docker:#NOM DU 1ER JOB
    runs-on: ubuntu-latest
    steps:
      -
        name: Set up Docker Buildx #this will biuld a docker image for us
        uses: docker/setup-buildx-action@v2
      -
        name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }} #this info will be store into gitHub/repoName/setings/security/secrets variable web site 
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      -
        name: Build and push
        uses: docker/build-push-action@v4
        with:
          push: true
          tags: stnmboa/reactivities:latest #NOM DE L'APPLICATION
  deploy: #NOM DU 2EME JOB
    needs: docker #NEED <=> L'EXECUTION DU JOB "deploy" REQUIERT L'ATTENTE DE L'EXECUTION DU JOB "docker"
    name: Deploy app
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - run: flyctl deploy --remote-only

  5) apres le push sur la branche main, on va sur Action/docker-push. on devrait avoir 2 jobs (docker - deploy App)

  /************************************************************************************/
  HOW TO ACCESS DB INTO FlyIo
  In order to access to the app DB from FlyIO, we need to create a "proxy". just use the followings cmd:

  1) fly apps list # to list all apps on Fly.io
  2) fly proxy <a port number from which we want to access DB>:<DB port on flyIO> -a <name od the DB app>
      $ fly proxy 6543:5432 -a reactivities-api-app-db
      this cmd allows us to accesss to DB from the localHost on port 6543

  3) from vsCode, after install postgres extension, go to create a new db connection
    host: localhost
    username: postgres
    password: it's what we save previously after the creation of the DB on fly.io (si on n'a pas save les infos 
      de la DB créée sur fly.io, alors, on a aucun moyen de recuperer le mot de passe de la DB créée.
      la seule chose a faire, c'est de supprimer et de recréer une nouvelle DB sur fly.io)
  4) standard Connection
  5) choose <DB_name>?sslmode=disable
  6) insert a displayName for the DB

  /************************************************************************************/
  SECURITY: 
  In order to check if the http headers are ok, we can check via the website:
    https://securityheaders.com/
  We must enter the link of our website: https://reactivities-api-app.fly.dev/
  Ath this time, we get a RESULT = F (the worse!!!!)

  the HTTP headers are missing. To enforce security, we MUST add them.

    - Strict-Transport-Security: HTTP Strict Transport Security is an excellent feature to support on your site
        and strengthens your implementation of TLS by getting the User Agent to enforce the use of HTTPS.
        Recommended value "Strict-Transport-Security: max-age=31536000; includeSubDomains".
    
    - Content-Security-Policy: is an effective measure to protect your site from XSS attacks. By whitelisting
        sources of approved content, you can prevent the browser from loading malicious assets.

    - X-Frame-Options: tells the browser whether you want to allow your site to be framed or not. By preventing
        a browser from framing your site you can defend against attacks like clickjacking.
        Recommended value "X-Frame-Options: SAMEORIGIN".
    
    - X-Content-Type-Options: stops a browser from trying to MIME-sniff the content type and forces it to stick
        with the declared content-type. The only valid value for this header is 
        "X-Content-Type-Options: nosniff".
    
    - Referrer-Policy: is a new header that allows a site to control how much information the browser includes
        with navigations away from a document and should be set by all sites.

    - Permissions-Policy: is a new header that allows a site to control which features and APIs
        can be used in the browser.
        
  We must setup the app in order to get grade = A (the best)

  1) install a nuget package (for the API project):
    NWebsec.AspNetCore.Middleware by André N. Klingsheim (v.3.0)

  2) add this config into the program.cs file after app.UseMiddleware<ExceptionMiddleware>();

    app.UseXContentTypeOptions(); //header = X-Content-Type-Options: prevents app from Mime Sniffing pof the content type
    app.UseReferrerPolicy(opt => opt.NoReferrer()); //header = Referrer-Policy
    app.UseXXssProtection(opt => opt.EnabledWithBlockMode()); // header = Content-Security-Policy: add a protection against the cross site scripting header
    app.UseXfo(opt => opt.Deny()); //X-Frame-Options

    // we use this in dev Mode to check the headers which we want to enable via the "CustomSource(...)"
    app.UseCspReportOnly(opt => opt //header= Content-Security-Policy-Report-Only
        .BlockAllMixedContent() //ceci force l'app á charger que du contenu HTTPS ou juste HTTP. Mais pas un mix des 2
        .StyleSources(s => s.Self()
            .CustomSources("https://fonts.googleapis.com") // exception: ok pour ce contenu
        ) //approuve seulement les CSS provenant de notre APP (wwwroot)
        .FontSources(s => s.Self()
            .CustomSources("https://fonts.gstatic.com", "data:") // exception: ok pour ce contenu
        ) //approuve seulement les fonts provenant de notre APP (wwwroot)
        .FormActions(s => s.Self()) //approuve seulement les form action provenant de notre APP (wwwroot)
        .FrameAncestors(s => s.Self()) //approuve seulement les frame provenant de notre APP (wwwroot)
        .ImageSources(s => s.Self().CustomSources("blob:", "https://res.cloudinary.com")) //approuve seulement les images provenant de notre APP (wwwroot)
        .ScriptSources(s => s.Self()) //approuve seulement les scripts action provenant de notre APP (wwwroot)
    );

  /************************************************************************************/
  SECTION 23 - IDENTITY/SECURITY COOKBOOK>>>>>PART 1 : FACEBOOK LOGIN
    
    for these new features, we will create a new branch
      git checkout -b sect23_facebookLogin

    in this section, we will focus on the following topics:
      - Facebook login: allow a user to register/login into the app using facebook credential. Steps to do so are:
        * Client login to Facebook
        * Facebook login success => facebook returns access tokrn to the client
        * Client sends access token to the API
        * API verifies token with Facebook
        * Token verified return user info
        * API register user and issues JWT

        Setup Facebook login:
          before the setup, the developer must have a Facebook account.
          a) go to: https://developers.facebook.com/?locale=fr_FR
          b) login with your personal facebook credentials and then go to "Apps" or "Demarrer"
          c) Click on "Create App"/Type = "Consumer/Consommateur"/AppName/Create App
          d) go to Facebook Login on your left bottom./Settings>Valid OAuth redirect URIs: 
            - add a value for localhost:3000 (front end app)
            - add a value for prod app :https://reactivities-api-app.fly.dev
            - Checkbox: Login With the JavaScript SDK: Yes
              d) go to Facebook Login on your left bottom./Settings>Domaines Autorisés pour le SDK Javascript: 
            add a value for localhost:3000 (front end app)
            add a value for prod app :https://reactivities-api-app.fly.dev
          e) click on save modifications
          f) go to "App Roles" (menu on your left)/Test users/create 2 tests users/Do You want this automatically installed for test users? > NO
          g) install the npm package:
            npm i @greatsumini/react-facebook-login@3.3.0
          h) Add the facebook login button on the app HomePage and add the corrisponding methos into the accountController (API)
          i) before made a test from the localhost (which runs on http://localhost:3000), we MUST INSTALL "mkcert"'
            "mkcert" creates a new local certificate authority which will simulate https request on localHost
              https://github.com/FiloSottile/mkcert
              To install "mkcert" on windows, we need to install "chocolatey"
                the cmd to install "mkcert" is (open powereshell as Admin): 
                  choco install mkcert
            - after installation, go back to client-app directory from the CLI and run the cmd:
              $mkcert -install
              $mkcert localhost
          j) after test that the facebookLogin works perfectly, we must add Facebook_AppId into the "fly.toml" file
              into the "env" (environnment variable): "Facebook__AppId="AppID took from the developers.facebook,com/settings"
          k) then add Facebook__ApiSecret int to the fly secrets list using the following cmd:
            fly secrets set Facebook__ApiSecret="App Secret took from the developers.facebook,com/settings

          l) NOW WE ARE READY TO DEPLOY THE APP 
            * DEPLOY THE FRONT-END APP INTO wwwroot by running cmd: $cd client-app; npm run build 
            * in order to test the new frontEnd build on localhost:5000, we must add "localhost:5000"
              in developers.facebook.com/facebook Login/settings>Valid OAuth redirect URIs> Add "localhost:5000"
              DO THE SAME FOR > Allowed domains for the JavaScript SDK
            * update "applicationUrl" from launchSettings.json: "applicationUrl": "https://localhost:5000",
            * TO VERIFY IF the https certificate is already installed for the localhost:5000, we must run this
              into the root folder Reactivities:
                $ dotnet dev-certs https >>>>A valid HTTPS certificate is already present.
              In case of problems with the https certificate, run:
                $ dotnet dev-certs https --clean
                $ dotnet dev-certs https --trust
          m) at this point, we can commit on the local branch and push/sync with remote
          n) to deploy the app, we must merge our changes from the feature branch to Main branch 
            $ git checkout main
            $ git merge sect23_facebookLogin
            $ git push origin main

  /************************************************************************************/
  SECTION 23 - IDENTITY/SECURITY COOKBOOK>>>>>PART 2 : REFRESH TOKEN
      - Refresh Tokens: reduce the lifetime of our current token and increase security about token JWT.
        * It carries information to get a new access token. This allows us to reduce validity time of JWT Token
        * It checks the expiration time of current access_token
        * Long lived
        * Refresh token can be stored into the DB with the user object as well as on the client (FrontEnd)
        * Refresh token can be stored into Http only cookie (so it can't be accessible via JavaScript(GOOD), 
          étant Http, il sera envoyé via chsque requete HTTP)
        * Le but ici est d'obtenir ubn NOUVEL ACCESS_TOKEN avant l'expiration du access_token courant
        * Le fonctionnement du refresh token est:
            # Login du user avec ses credentials
            # le serveur repond avec un token JWT (stocker dans le local Storage)
            # avant expiration du token JWT, une requete HTTP (api/account/refreshToken <=> cookie) part du 
              serveur vers le front et fait une update du token JWT. Ceci est transparent pour l'user 

        * After the creation of the Domain Class (RefreshToken), we can create a new migration by running
          $ dotnet ef migrations add sect23_addedRefreshToken -p Persistence/ -s API/
        * Create the method: GenerateRefreshToken for the front/back end


      - Email confirmation: send a verification Email for new users to confirm the email used by them for registration
      Nous ne mettrons pas en place un serveur de messagerie, mais nous utliserons un service "SendGrid". Si nous
      decidons d'implementer un service mail from scratch, alors, le mail de confirmation ira certainement dans 
      les mails indésiderable car tout est basé sur la confiance en ce qui concerne les mails
        * to use SendGrid, we need to create a free account. 
        * UserManager: fournit des fonctionnalités en lien avec <Microsoft.AspNetCore.Identity.UserManager>
        * Email Verification Token: en résumé:
          a) we generate an email confirmation token
          b) we send the email to the client Inbox
          c) then the client receive the confirmation email, and it clik's on a link
          d) the link is a request which will go to a specific API endPoint. If the token match with what we store 
          before into the DB, so, we can be sure that the user can access to registration Email address use for it 
          registration.
            The token (furnish by th Identity) is a combination of: "SecurityStamp" and "machine key"

        A) create an account into SendGrid.com
        B) create an email account for the app (app_reactivities@outlook.com). this is a verified Email Account which
          will be used to send email to users for email verification etc...
          * To add an appEmail account into sendGrid, go to the Settings>Sender Authentication> Add the app email
          * Make sure the app email address is verified on SendGrid
        C) from SendGrid Settings, go to Tracking: we need to disable all settings
        D) Finally go to API Keys and click on "Create API key"

        Setup SendGrip:
          * Go to API project, 
          * NugetGallery>Install "SendGrid by Elmer Thomas, Twilio DX Team v.9.22.0" for "Infrastructure" project
          * Go to appsettings.json and add:
            "SendGrid" : {
                "User": "app_reactivities@outlook.com",
                "Key": "<Api Key created from SendGrid/settings>"
            }
          * Create a service into Infrastructure project to send email

          * after each deploy of our client-app into the wwwroot folder, WE MUST SET THE CORRECT VALUE OF THE HASH-KEY
            INTO THE POLICY: 
              app.UseCsp(opt => opt
                .BlockAllMixedContent()
                .StyleSources(s => s.Self()
                    .CustomSources("https://fonts.googleapis.com", "sha256-DpOoqibK/BsYhobWHnU38Pyzt5SjDZuR/mFsAiVN7kk=")
                    ...
  END THIS COURSE!!!
  /************************************************************************************/
  /************************************************************************************/
  